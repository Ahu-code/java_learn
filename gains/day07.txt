看完等待与唤醒，线程池


----------------------------------------
1.Timed Waiting（计时等待）Thread.sleep()//毫秒
2.BLOCKED（锁阻塞）
3.等待与唤醒
-------------------------
3.等待与唤醒
/*
 * 一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的
 * Object.notify()方法 或 Object.notifyAll()方法。
 * 等待与唤醒机制
 * 注意：
 * 顾客和老板线程必须使用同步代码块包裹起来，以保证等待与唤醒只有一个在执行
 * 同步使用的锁对象必须唯一
 * 只有锁对象才能调用wait() 和 notify()
 */
/* 在Object类中
 * void wait() 使当前线程等待另一个线程调用此对象的方法或 notify() /notifyAll()方法。  
 * void notify() 唤醒一个在这个对象的监视器上等待的单个线程,执行wait之后的代码。
 */
----------------
//创建锁对象，保证唯一
Object obj = new Object();
//创建一个顾客线程
new Thread() {
	public void run() {
		//
		synchronized (obj) {
		System.out.println("告诉老板包子种类和对象")				try {
			obj.wait();								System.out.println("取走包子");
		}catch (InterruptedException e) {						e.printStackTrace();
		}
		}
	}
}.start();
		
//创建一个老板线程
new Thread() {
	public void run() {
	//先睡眠5秒
	try {
	Thread.sleep(5000);
	} catch (InterruptedException e) {
		e.printStackTrace();
	}		
	//保证等待和唤醒的线程只能有一个执行，需要使用同步技术
	synchronized (obj) {
		System.out.println("老板做好包子了，告知顾客可以来吃了");
		obj.notify();
	}
	}
}.start();
------------------------------------------------
2.如何保证线程间通信有效利用资源：
多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就
是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效
的利用资源。而这种手段即—— 等待唤醒机制。
---------------------------------------------------
3.等待与唤醒各方法的含义
就是在一个线程进行了规定操作后，就进入等待状态（wait()）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（notify()）;
-----------------
1. wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个特别的动作，也即是“通知（notify）”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中
2. notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。（队列）
3. notifyAll：则释放所通知对象的 wait set 上的全部线程。
------>>>注意
 1.wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。
 2.wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。
----------------------------------------------------------
4.线程池---是一个容器
1.线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源
--->JDK1.5之后，自动实现了线程池      java.util.concurrent.Executors
----->好处：
1. 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
2. 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
3. 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。
----------------------------------------------------------
 *   使用线程池中线程对象的步骤：
1. 创建线程池对象。（使用Executors工程类中的newFixedThreadPool方法 来创建线程池对象。）
2. 创建Runnable接口子类对象，重写run方法，设置线程任务。
3. 提交Runnable接口子类对象。（调用ExecutorService中的submit方法，传递线程任务，开启线程
--submit(Runnable task)
4. 关闭线程池(一般不做)。---->调用shutdown方法，一般不用