终于学了网络编程，搭建在网站上也太有成就感了吧啊喂！


=====================================
一、基础知识：
1.软件结构
1.C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件
2.B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等
网络编程，就是在一定的协议下，实现两台计算机的通信的程序。
--------------------------------------------------
2.协议分类
1.UDP：（耗资小，效率高，易损失，数据被限制在64kb以内）
用户数据报协议(User Datagram Protocol)。UDP协议是一个面向无连接的协议。传输数据时，不需要建立连接，不管对方端服务是否启动，直接将数据、数据源和目的地都封装在数据包中，直接发送。每个
数据包的大小限制在64k以内。它是不可靠协议，因为无连接，所以传输速度快，但是容易丢失数据。日常应用中,例如视频会议、QQ聊天等。
2.TCP：（安全，但效率没有UDP高）
传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。
*三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。
第一次握手，客户端向服务器端发出连接请求，等待服务器确认。
第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。
第三次握手，客户端再次向服务器端发送确认信息，确认连接。
-----------------------------------------------------
3.网络编程三要素
  1.IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。
IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。
     IP地址分类：IPv4，IPv6
  1）IPV4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d 的形式，例如192.168.65.100（10进制） 。其中a、b、c、d都是0~255之间的十进制整数，那么最多可以表示42亿个。（2^32）
  2）IPv6（指的是16个字节一组）：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。有资料显示，全球IPv4地址在2011年2月分配完毕。
为了扩大地址空间，拟通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，表示成ABCD:EF01:2345:6789:ABCD:EF01:2345:6789 ，号称可以为全世界的每一粒沙子编上一个网址，这样就解决了网络地址资源数量不够的问题。
-----------
查看本机IP地址，在控制台输入：ipconfig
查网络是否连通，在控制台输入：ping 空格 IP地址——ping 220.181.57.216
本机IP地址： 127.0.0.1 、localhost
------------------------------------
4.端口号
网络的通信，本质上是两个进程（应用程序）的通信。每台计算机都有很多的进程，那么在网络通信时，如何区分这些进程呢？
如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的进程（应用程序）了。
端口号：用两个字节表示的整数，它的取值范围是0~65535。其中，0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以后的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败。
利用协议+ IP地址+ 端口号 三元组合，就可以标识网络中的进程了，那么进程间的通信就可以利用这个标识与其
它进程进行交互。
-----------
几个常见的端口号：
1.80端口： www.baidu.com:80对    www.baidu.com:70 错
2.数据库         mysql：3306  Oracle：1521
3.Tomcat服务器：8080    
-----------------------------------------
4.TCP通信程序
TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）与服务端（Server）。
两端通信时步骤：
1. 服务端程序，需要事先启动，等待客户端的连接。（事先启动服务器）
2. 客户端主动连接服务器端，连接成功才能通信。服务端不可以主动连接客户端。
----->>>>这个连接中包含一个对象，这个对象即为IO对象
通信的数据不仅为字符，是字节流对象
output发送数据，input读取
客户端与服务端进行一个数据交互，需要4个流对象
-----------------------------------------------
5.模拟B\S服务器（太想学好这个了!!!!）
模拟网站服务器，使用浏览器访问自己编写的服务端程序，查看网页效果。
//写入协议响应头，固定写法
os.write("HTTP/1.1 200 OK\r\n".getBytes());
os.write("Content‐Type:text/html\r\n".getBytes());
os.write("\r\n".getBytes());
------
//浏览器工作原理是遇到图片会开启一个线程进行单独的访问,因此在服务器端加入线程技术。
//请求一次就开一个线程
------
因为需要用到  readline方法  读取传至服务器端的第一行，
因此需要用字符缓冲输入流
BufferedReader br = new BufferedReader(new InputStreamReader(is));
===================================
===================================
===================================
===================================
客户端与服务器端方法：
5.服务器必须明确地两件事：
    1.多个客户端同时和服务器交互，服务器必须明确和哪个客户端交互，在服务器中有一个方法，叫accept，获取到请求的客户端对象
    2.多个客户端同时和服务区进行交互，就需要使用多个IO流对象
          且服务区没有IO流，但服务器可以获取到请求的客户端对象Socket，使用每个客户端Socket中提供的IO流对象和客户端进行交互
         即服务器使用客户端的流与客户端交互
Socket s1 = server.accept（）
------------------------------------------
6. 客户端
 * TCP通信的客户端：向服务器发送连接请求，给服务器发送数据，读取服务器回写数据
 * java.net.Socket
 *   这个类实现了客户端套接字（也被称为“套接字”）。套接字是两台机器之间的通信的一个端点。
 *   套接字:包含了Ip地址和端口号的网络单位
 *   
 *   构造方法：
 *   Socket(String host, int port) 创建一个流套接字，并将其与指定的主机上的指定端口号连接起来。Socket socket = new Socket("127.0.0.1",8888);
 *   
 *   String host :服务器主机的名称/服务器的IP地址
 *   int port： 服务器的端口号
 *   
 *   成员方法：
 *   	OutputStream getOutputStream() 返回此套接字的输出流。 
 *   	InputStream getInputStream() 返回此套接字的输入流。 
 *   	void close() 关闭这个套接字   
 *   
 *   实现步骤：
 *  1.创建一个客户端对象Socket，构造方法绑定服务器的IP地址和端口号
 *  2.使用Socket对象中的getOutputStream() 获取网络字节输出流OutputStream对象 。
 *  3.使用网络字节输出流OutputStream对象中的write方法，给服务器发送数据
 *  4.使用Socket对象中的 getInputStream() 获取网络字节输入流InputStream对象 。 
 *  5.使用网络字节输入流InputStream对象中的read方法，读取服务器中回写的数据
 *  6.关闭资源(Socket)
 *   注意：
 *   1.客户端和服务器进行交互，必须使用Socket中提供的网络流，不得使用自己创建的对象
 *   2.当我们创建客户端对象Socket的时候，就会去请求服务器和服务器经过3次握手建立连接通路，这时，如果服务器还未启动，就会抛出异常
 */
--------------------------------------------------------
7.服务器端
 * TCP通信的服务器端，接收客户端的请求，读取客户端发送的数据，给客户端回写数据
 * 表示服务器的类：ava.net.ServerSocket
 * 
 *  构造方法：
     ServerSocket server = new ServerSocket(8888);
 *  ServerSocket(int port) 创建一个服务器套接字，绑定到指定的端口。
 *  服务器必须明确是哪个客户端请求的服务器，
	因此使用accept方法，来获取客户端对象Socket
 *  Socket accept() 监听要对这个套接字作出的连接并接受它。  
 *  
 *  服务器实现步骤：
 * 1.创建服务器ServerSocket对象和系统要指定的端口号
 * 2.使用serverSocket对象中的方法accept，获取客户端对象Socket
 * 3.使用Socket对象中的 getInputStream() 获取网络字节输入流InputStream对象 。 
 * 4.使用网络字节输入流InputStream对象中的read方法，读取客户器中发送的数据
 * 5.使用Socket对象中的getOutputStream() 获取网络字节输出流OutputStream对象 。
 *6.使用网络字节输出流OutputStream对象中的write方法，给客户端回写数据
 * 7.释放资源（Socket， ServerSocket）
 */
====================================
====================================
文件上传案例：
 * 1. 【客户端】输入流，从硬盘读取文件数据到程序中。 
 * 2. 【客户端】输出流，写出文件数据到服务端。
 * 3. 【服务端】输入流，读取文件数据到服务端程序。
 * 4. 【服务端】输出流，写出文件数据到服务器硬盘中。
-----服务器步骤见TCPloadFileServer.java
-----客户器步骤见TCPloadFileClient.java
------------------------------------------------------------
注意：会出现while死循环，原因如下：
//while会发生死循环，因为第一次在客户端读入文件时，在-1结束，但不能把-1读入，
//即上传服务器时，没有结束标志
//read方法:如果 len不为零，该方法阻塞直到输入可用；否则，没有字节读取和 0返回。

--------------->>>>解决措施：
/*
 * void shutdownOutput()   加上终止标志符（只在客户端发给服务器时）
 * 对于一个TCP套接字，先前写入的数据将被发送后正常关闭TCP连接,后跟终止。
 */
-------------------------------------------------------------
-------------------------进行优化----------------------------
1.文件名称写死的问题
服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：
FileOutputStream fis = new FileOutputStream(System.currentTimeMillis()+".jpg") // 文件名称
BufferedOutputStream bos = new BufferedOutputStream(fis);
2. 循环接收的问题
服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：
// 每次接收新的连接,创建一个Socket---->搞个死循环
while（true）{
Socket accept = serverSocket.accept();
......
}
3. 效率问题
服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：
// 每次接收新的连接,创建一个Socket
while（true）{
Socket accept = serverSocket.accept();
// accept 交给子线程处理.
new Thread(() ‐> {
......
InputStream bis = accept.getInputStream();
......
}).start();
}

------------------------------------
===================================

零碎知识点：
1.
java Random.nextInt()方法
public int nextInt(int n)
该方法的作用是生成一个随机的int值，该值介于[0,n)的区间，也就是0到n之间的随机int值，包含0而不包含n。
2.
public String substring(int beginIndex)
或
public String substring(int beginIndex, int endIndex)
beginIndex -- 起始索引（包括）, 索引从 0 开始。
endIndex -- 结束索引（不包括
